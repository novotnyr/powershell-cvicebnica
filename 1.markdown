---
title: Cvičebnica z Powershellu, časť 1
layout: page
---

Inštalácia
=========

**PowerShell 2.0** je automaticky dostupný vo Windows 7 a Windows 2008 R2. Pre staršie verzie Windowsu navštívte [http://support.microsoft.com/kb/968929](http://support.microsoft.com/kb/968929) a stiahnite *Windows Management Framework Core (WinRM 2.0 and Windows PowerShell 2.0)*.

Od septembra 2012 je k dispozícii **PowerShell 3.0** pre Windows 7 Service Pack 1, Windows Server 2008 R2 SP1, Windows Server 2008 Service Pack 2. 

V tomto tutoriále sa však stále budeme venovať verzii 2.0.

Úvodné úlohy
=============

Spustite PowerShell
-------------------

	Start | powershell.exe

Vyskúšajte vlastnosti kalkulačky, zrátajte (2 + 3) * 10.
-------------

	(2 + 3) * 10

Zistite, akú verziu PowerShellu používate.
------------------------------------------

	Get-Host

Príkazy nerozlišujú veľké a malé písmena.

<div markdown="1" class="alternative-solution">
Podobnú informáciu obsahuje aj premenná `$PSVersionTable`.
</div>

Spustite Powershell 2.0
-----------------------
Na moderných Windowsoch sa automaticky spúšťa najnovší Powershell. Na zachovanie spätnej kompatibility môžete explicitne spustiť konkrétnu verziu.

	powershell -version 2.0

Overte následne spustenú verziu.

Spustite Prieskumníka
---------------------

	explorer

alebo

	explorer.exe

Možno spúšťať bežné programy, ktoré sú dostupné v systéme.

Zistite, v ktorom adresári sa práve nachádzate.
-----------
Zistiť to môžeme pohľadom na výzvu (prompt).

	PS C:\Users\rn>

Zistite, v ktorom adresári sa práve nachádzate pomocou `pwd`.
-------------------------

	pwd

Zobrazte súbory a adresáre v aktuálnom podadresári pomocou `ls`.
------------------------
	
	ls

Zobrazte súbory a adresáre v aktuálnom podadresári pomocou `dir`.
------------------------

	dir

Zobrazte súbory a adresáre v aktuálnom podadresári pomocou `Get-ChildItem`.
------------------------

	Get-ChildItem

Zistite všetky alternatívne názvy pre výpis súborov a adresárov
-------------------

	alias dir

alebo

	alias ls

PowerShell neraz definuje pre jeden príkaz viacero alternatívnych názvov. Zabudovaný príklad PowerShellu sa nazýva **cmdlet** (commandlet): príkladom je `Get-ChildItem`, ktorý má aliasy `dir` aj `ls`.

Preštudujte dokumentáciu k `ls` / `dir` / `Get-ChildItem`
------------------------
	
	man ls

alebo

	man dir

alebo 

	man Get-ChildItem

alebo 

	help Get-ChildItem

Skúste tiež

	man man

Príklady môžete získať cez:

	man ls -examples

Zobrazte len názvy súborov či adresárov v aktuálnom adresári.
------------------------------------------------------------

	ls –Name

Názvy parametrov možno skrátiť, pokiaľ nedôjde k nejednoznačnostiam.
	
	ls -n

Zapíšte názvy súborov a adresárov do externého súboru.
--------------

	ls -n > subory.txt

Výstup ľubovoľného cmdletu možno zapísať do textového súboru použitím presmerovania cez `>`.

Overte existenciu súboru `subory.txt`
--------------

	ls subory.txt

Alternatívne pomocou cmdletu `Get-Item`˛

	Get-Item subory.txt

Alternatívne pomocou cmdletu `gi`, aliasu pre `Get-Item`

	gi subory.txt

Otvorte `subory.txt` v textovom editore
---------------

	notepad subory.txt

Pohyb v prostredí
------------------
* Šípky hore a šípky dole sa pohybujú po histórii príkazov
* Tabulátor realizuje automatické dopĺňanie.
* Kliknutím myši a ťahaním môžete vybrať text a pravým klikom ho skopírovať do schránky.
* cmdlet `cls` / `Clear-Host` zmaže obrazovku.


Adresáre
=========

Vypíšte obsah vlastného domovského adresára.
----------
Ak ste v domovskom adresári, tak:

	ls

Presun do domovského adresára:
	
	cd ~

A následne:
	
	ls

Alternatívne z ľubovoľného adresára
	
	ls ~

Vlnka `~` je skratka pre cestu do domovského adresára.

Vypíšte všetky súbory a adresáre v `C:/Users`
------

	ls C:/Users

Vypíšte všetky súbory a adresáre v `C:/Users`, ktoré sa začínajú na „P“.

Možnosť 1:

	cd C:\Users
	ls P*

Možnosť 2:

	ls C:\Users\P*

Vypíšte všetky súbory typu XML v domovskom adresári.
----------

	ls ~ *.xml

Alebo (ak sme v domovskom adresári):

	ls *.xml

Vypíšte všetky súbory v domovskom adresári a vo všetkých jeho podadresároch.
---------------------------------

	ls –Recurse

alebo
	
	ls -r

Vypíšte všetky XML súbory v domovskom adresári a vo všetkých jeho podadresároch.
------------------------------------------
Pozor! Pokus o 

	ls *.xml –r

nepovedie k výsledku! Prvým nepomenovaným argumentom musí byť aktuálny adresár, druhým je filter. Korektný príkaz je 

	ls ~ *.xml -r

čo je skrátenina pre

	ls -Path . -Filter *.xml -Recurse 

Ak sa nachádzame v domovskom adresári, potom:

	ls . *.xml –r

(Prvý parameter je bodka, druhý filter)


Vypíšte len plochý zoznam súborov z predošlej úlohy
----------------
	
	ls ~ *.xml -Recurse -Name

Spočítajte, koľko je súborov z predošlej úlohy
-----
Vystavajme rúru a výsledok z `ls` pošlime do cmdletu `measure`, ktorý vie robiť štatistické výpočty

	ls ~ *.xml -Recurse | measure

Vo výslednej položke `Count` nájdeme výsledok.

Cmdlet `measure` je aliasom pre `Measure-Object`.

Spočítajte, koľko miesta zaberajú všetky súbory v domovskom adresári
---------------------------
Cmdlet `measure` má parameter `–Sum`, ktorý popri počte položiek vie rátať aj sumy veľkostí. Musíme však určiť, podľa ktorého atribútu sa má sčítavať. Dosiahneme to pomocou prepínača `–Property`.

	ls ~ -Recurse -Force | measure –Property Length -Sum

Každý súbor má atribút `Length` udávajúci jeho veľkosť (adresáre ju majú prázdnu).

Pozn. pre hnidopichov: neberú sa do úvahy skryté súbory a softlinky sa vyhodnotia nesprávne.

Vypíšte len adresáre v domovskom adresári
------------------------------

	ls | where {$_.PSIsContainer}

cmdlet `Where` slúži na filtrovanie. V kučeravých zátvorkách sa nachádza výraz (_expression_) s booleovskou podmienkou. 

Cmdlet `ls` produkuje zoznam objektov. Cmdlet `where` vyhodnotí každý prvok tohto zoznamu, dosadí ho do špeciálnej premennej `$_` a v prípade, že je podmienka splnená, zahrnie ho do výstupného zoznamu. 

Atribút `PSIsContainer` je pravdivý pre adresáre, pre súbory nie.

Cmdlet `where` je aliasom pre `Where-Object`. 

Alternatívny alias je `?`

	ls | ? { $_.PSIsContainer }

Zistite, koľko súborov sa nachádza v domovskom adresári a jeho podadresároch.
---------------------------------------
	
	ls -r | where {-not $_.PSIsContainer} | measure

`-not` je negácia podmienky.

Alternatívne možno použiť výkričník

	ls -r | where {!$_.PSIsContainer} | measure

Alternatívne:
	
	ls -r | where {$_.PSIsContainer -eq $False} | measure

Vypíšte súbory a adresáre v domovskom adresári zotriedené podľa mena
------------------------------

	ls | sort

Tento príkaz robí to isté, čo prostý `ls`, pretože súbory na výstupe sú už štandardne zotriedené podľa mena.

Cmdlet `sort` je alias pre `Sort-Object`.

Vypíšte len súbory zotriedené podľa veľkosti
--------

	ls | where {-not $_.PSIsContainer} | sort Length

Cmdlet `sort` má parameter, v ktorom určíme atribút, podľa ktorého sa má triediť. Triedime podľa veľkosti (`length`).

Alternatívne:

	ls | where {-not $_.PSIsContainer} | sort –Property Length

Vypíšte súbory a adresáre zotriedené podľa veľkosti zostupne.
-----------------------------------

	ls | sort length –Descending

Prepínač možno skrátiť na 

	ls | sort length –desc

Ak sa parameter skráti na `–d`, nastane chyba nejednoznačnosti názvu parametra (pri sorte existujú dva: `-debug` a `–descending`)

Nájdite najväčší súbor v domovskom adresári (nevnárajte sa do podadresárov)
---------------------------------------------

	ls | sort Length -Desc | select -first 1

Cmdlet `select` obvykle filtruje objekty podľa atribútov, ale umožňuje filtrovať prvých/posledných _n_ záznamov. V skutočnosti je to alias pre `Select-Object`.

Vypíšte plné cesty k všetkým súborom a adresárom v aktuálnom adresári
---------------

	ls | select FullName

Nájdite plnú cestu a veľkosť najväčšieho súboru v domovskom adresári vrátane podadresárov.
--------------------

	ls -r | sort length -desc | select FullName, Length -first 1

cmdlet `select` umožňuje špecifikovať atribúty, ktoré sa objavia na výstupe. V tomto prípade vyberáme plnú cestu (`FullName`) a dĺžku (`Length`).

Nájdite plné cesty k všetkým súborom väčším než 20 MB.
-------------------------------

	ls -r | where {$_.length -ge 20MB} | select FullName

Pozor! Porovnanie sa realizuje pomocou `–ge`. Znak `>` znamená presmerovanie a jeho použitie v porovnávaní povedie k chybe, resp. k presmerovaní do súboru s obskúrnym názvom.

Vypíšte súbory a adresáre určené len na čítanie.
----------------------------
Jeden spôsob využíva atribút `Mode`.

	ls | where {$_.Mode -match "r"}

Operátor `–match` využíva regulárne výrazy. Tu stačí povedať, že hľadá prítomnosť podreťazca v reťazci. Ak mode obsahuje v hodnote „r“, súbor je read-only.

Alternatívne:

	ls | where {$_.mode -like "*r*"}

Operátor `–like` funguje podobne ako v databázach, pričom vieme vyhľadávať s použitím žolíkov. 

Alternatívna, ale mylná možnosť je využiť vlastnosť `isReadOnly`; tá však funguje len na súboroch.


Formátovače
===========

Vypíšte názov a plnú cestu k súboru v užšom formáte
---------------------------------------------------

	ls | select Name, FullName | Format-Table -AutoSize

alebo

	ls | select Name, FullName | ft -a

Na konci každej rúry je formátovač, ktorý zapíše objekty v primeranom tvare na konzolu. Ak neuvedieme žiaden formátovač, použije sa zväčša tabuľkový formátovač `Format-Table`.

Parametrom `-AutoSize` nastavíme automatické šírky stĺpcov podľa najširšej položky.

Porovnajte tiež ďalšie formátovače:

*	`Format-Wide` / `fw`: na šírku
*	`Format-List` / `fl`: do zoznamu pod seba.


Procesy
========

Vypíšte zoznam všetkých bežiacich procesov.
-------------------------

	ps

Vypíšte počet bežiacich inštancií `svchost`u.
-------------------------

	ps svchost | measure

Vypíšte zoznam atribútov, na ktoré sa môžete dopytovať pri procese
-------------------------

	ps | gm

Vypíšte zoznam procesov a ku každému procesu vypíšte cestu k spúšťaciemu súboru.
-------------------------

	ps | select Name, Path 

Alternatívne možno použiť cmdlet `Format-Table` (`ft`), kde možno prispôsobiť šírku stĺpcov

	ps | ft Name, Path –a

Zistite, koľkokrát beží proces spustený súborom `C:\Windows\system32\notepad.exe`
-------------------------

	ps | where {$_.Path -eq "C:\Windows\system32\notepad.exe" } | measure

Vypíšte mená a cesty procesov, ktoré boli spustené z C:\Program Files
-------------------------

	ps | where {$_.Path -match "C:\\Program Files" } | ft Name, Path

Potrebné je zdvojenie lomiek (\\), pretože lomka má v regulárnych výrazoch špeciálny význam. Regulárne výrazy preberieme neskôr.

Vypíšte procesy a ich vyťaženie CPU v zostupnom usporiadaní.
-------------------------

	ps | sort -Descending CPU | ft Name, CPU –a

Samozrejme, parameter `–Descending` možno skrátiť:

	ps | sort -desc cpu | ft name, cpu –a

Vypíšte jedno meno procesu, ktoré najviac vyťažuje procesor.
-------------------------
	
	ps | sort -desc cpu | select -first 1 | ft name, cpu -a

Spustite novú inštanciu Skicára.
-------------------------
Klasická možnosť

	mspaint

Alternatívne

	start mspaint

Cmdlet `start` je alias pre `Start-Process`

	Start-Process mspaint

Ukončite všetky bežiace inštancie Skicára
------------------------------------------

	ps mspaint | kill

*	Na rozdiel od linuxového variantu nemusíme naháňať PIDy (ID procesu), ale môžeme do rúry poslať inštancie objektov, ktoré následne `kill` zabije.
*	`kill` je alias pre `Stop-Process`

Ukončite ešte raz všetky bežiace inštancie Skicára a pozorujte chybovú hlášku.
----------------------------------------

	Get-Process mspaint | Stop-Process

---
title: Cvičebnica z Powershellu, časť 2
layout: page
---

Služby
=======
Vypíšte zoznam všetkých služieb vo Windowse.
--------------------------------------------

	Get-Service

alternatívne

	gsv

Vypíšte zoznam všetkých bežiacich služieb.
-------------------------------------------

	gsv | where {$_.Status -eq "Running"}

Zastavte službu s názvom Themes.
-------------------------------------------
	Stop-Service Themes

alebo dlhšie, ale v súlade s filozofiou `ps`/`kill`:

	Get-Service Themes | Stop-Service

Znovu spustite službu s názvom Themes.
-------------------------------------------
	Start-Service Themes

alebo dlhšie, ale v súlade s filozofiou `ps`/`kill`:

	Get-Service Themes | Start-Service

Zistite, aké atribúty má objekt pre službu
-------------------------------------------

	Get-Service | Get-Member

alebo

	gsv | gm

Vypíšte služby spolu so závislými službami.
-------------------------------------------

	Get-Service | ft Name, ServicesDependedOn –a


Vypíšte služby, ktoré nezávisia na žiadnej službe.
-------------------------------------------

	gsv | where {$_.ServicesDependedOn} | select name

Atribút `ServicesDependedOn` je zoznamom. Hoci podmienka vo `Where` očakáva booleovský výraz, v prípade zoznamov platí, že podmienka je splnená vtedy, ak je zoznam neprázdny.

Zistite, ktoré služby závisia na službe HTTP
-------------------------------------------

	gsv HTTP -DependentServices

Pre každú službu vypíšte služby, na ktorých táto služba závisí
-------------------------------------------

	gsv | select displayname, dependentservices | sort displayname

.NET Framework
===============
Vypočítajte druhú odmocninu z 25
-------------------------------------------

	[Math]::Sqrt(25)

Použime statickú metódu `Sqrt()` na objekte `System.Math`.

Zahrajte štandardný zvuk Pípania vo Windowse
-------------------------------------------
	
	[Media.SystemSounds]::Beep.Play()

Stačí zavolať statickú inštančnú premennú `Beep` na triede `System.Media.SystemSounds`. (Namespace `System` je automaticky importnutý.) 

Premenná `Beep` je typu `System.Media.SystemSound` (ľahko overíme pomocou cmdletu `Get-Member`):

	[Media.SystemSounds]::Asterisk | Get-Member

Na `SystemSound`-e môžeme zavolať metódu `Play()`

WMI (Windows Management Instrumentation)
=========================================
Zistite veľkosť RAMky v počítači
--------------------------------

	Get-WmiObject Win32_ComputerSystem

Z vlastnosti `TotalPhysicalMemory` vidíme výsledok. Ak chceme len konkrétne číslo:

	(Get-WmiObject Win32_ComputerSystem).TotalPhysicalMemory

WMI objekt sa tvári ako štandardný powershellovský objekt: má inštančné premenné a metódy.

Voliteľne môžeme zistiť aj gigabajty:

	(Get-WmiObject Win32_ComputerSystem).TotalPhysicalMemory / 1GB

Výsledok bude:

	7,88347625732422

Zistite, koľko modulov RAM je v stroji
--------------------------------------

	gwmi Win32_PhysicalMemory | ft -a BankLabel, Capacity

Výsledok:

	BankLabel   Capacity
	---------   --------
	BANK 0    4294967296
	BANK 2    4294967296

Máme teda 2 moduly po 4GB.

Zistite zoznam všetkých fyzických diskov pripojených k počítaču
-------------------------------------------
	
	Get-WmiObject Win32_DiskDrive

`Win32_DiskDrive` je trieda zodpovedajúca fyzickému disku vo Windowse.

Zistite zoznam všetkých vlastností / metód, ktoré možno zistiť o fyzických diskoch.
-------------------------------------------

	Get-WmiObject Win32_DiskDrive | Get-Member

Zistite zoznam fyzických diskov, ktoré podporujú technológiu SMART
-------------------------------------------

	Get-WmiObject Win32_DiskDrive | where {$_.Capabilities -contains 10} | ft Caption

Technológia SMART (Self-Monitoring, Analysis, and Reporting Technology) umožňuje monitorovanie a varovanie pred zlyhaním disku. Podporuje ju takmer každý dostupný pevný disk.

Trieda [`Win32_DiskDrive`](http://msdn.microsoft.com/en-us/library/aa394132%28v=VS.85%29.aspx#properties) obsahuje vlastnosť `Capabilities` reprezentovanú poľom integerov. Ak pole obsahuje hodnotu 10, zariadenie podporuje SMART.

Nájdite fyzický disk s najväčšou kapacitou.
-------------------------------------------

	Get-WmiObject Win32_DiskDrive | sort size -desc | select -first 1

Dôležitá vlastnosť je `Size`.

Vypíšte zoznam všetkých logických jednotiek dostupných v systéme
----------------------------------------------------------------

	gwmi Win32_LogicalDisk | where {$_.DriveType -eq 3}

Dokumentácia (http://msdn.microsoft.com/en-us/library/aa394173(VS.85).aspx) udáva 3 ako konštantu pre lokálnych jednotku.

Vypíšte zoznam všetkých MP3jek na všetkých lokálnych jednotkách
---------------------------------------------------------------

	gwmi Win32_LogicalDisk 
	| ? {$_.DriveType -eq 3} 
	| % {dir $_.Caption -Recurse } 
	| ? {$_ -like "*.mp3"} 
	| ft name


Vypíšte zoznam všetkých tlačiarní pripojených k počítaču
-------------------------------------------

	Get-WmiObject Win32_Printer

Vypíšte názov implicitnej tlačiarne
-------------------------------------------

	Get-WmiObject Win32_Printer | where {$_.Default} | ft Name

Zistite zoznam všetkého nainštalovaného softvéru od Adobe
-------------------------------------------
	
	Get-WmiObject Win32_Product | where {$_.Caption -match "Adobe"} | sort Caption | ft Caption

Na niektorých inštaláciách Windows XP sa stretnete s chybou.

Zistite zoznam bežiacich procesov cez WMI
-----------------------------------------

	Get-WmiObject Win32_Process | ft -a ProcessId, Name, ExecutablePath

Alternatívne cez dopyty v jazyku WQL ([WMI Query Language](http://msdn.microsoft.com/en-us/library/aa392902(v=vs.85).aspx)):

	Get-WmiObject -Query 'select Name from Win32_Process'

WQL je podobný jazyku SQL. Názov triedy zodpovedá tabuľke, inštačné premenné stĺpcom.

Zistite zoznam bežiacich procesov z `C:\Windows`
------------------------------------------------

	Get-WmiObject -Query 'select Name from Win32_Process where ExecutablePath like "%C:\\Windows%"'

Alternatívne cez pretypovanie reťazca na objekt typu `wmisearcher`:

	$q = [wmisearcher] 'select Name from Win32_Process where ExecutablePath like "%C:\\Windows%"'
	$q.get()

Zistite info o procese s ID 0
------------------------------

	gwmi -query 'select * from Win32_Process where Handle=0'

alebo 

	gwmi Win32_Process -filter "Handle=0"

alebo pretypovaním reťazca na objekt typu `[wmi]`:

	[wmi] 'Win32_Process.Handle=0'

Pozor, táto posledná finta funguje len pre niektoré vlastnosti. Z dokumentácie pre konkrétnu triedu zistite, ktoré vlastnosti majú kvalifikátor (*qualifier*) **Key**. Napríklad [`Win32_Process`]((http://msdn.microsoft.com/en-us/library/aa394372%28v=vs.85%29.aspx)) má len vlastnosti `CreationClassName` a `Handle`. Podrobnejšie vysvetlenie je na [MSDN Blogu](http://blogs.msdn.com/b/powershell/archive/2008/04/15/wmi-object-identifiers-and-keys.aspx).

Reštartujte počítač
-------------------------------------------
	
	(Get-WmiObject Win32_OperatingSystem).Reboot()

`Get-WmiObject` pošle do rúry jeden objekt, na ktorom môžeme volať metódy z dokumentácie.

Alternatívne cmdletom:
	
	Restart-Computer

Providery
=========
Zistite všetkých providerov v systéme
-------------------------------------

	Get-PSDrive

Alebo:

	gdr

Vypíšte zoznam všetkých diskových jednotiek
--------------------------------------------

	Get-PSDrive | Where {$_.Provider -match "FileSystem"} | Select Root

alebo

	gdr | ? {$_.Provider -match "FileSystem"} | Select Root

Problém v tomto prípade spočíva v tom, že sú zahrnuté aj vymeniteľné jednotky (DVD mechaniky), v ktorých sa nemusí nachádzať disk a teda prípadný výpis ich obsahu zlyhá.

Vypíšte mená všetkých nainštalovaných fontov
---------------------------------------------

	(Get-Item "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts").Property | sort

Využijeme providera pre registre. "Jednotka" `HKLM:` zodpovedá registru `HKEY_LOCAL_MACHINE`, nastaveniam súvisiacim s celým systémom. 

Alternatívne s použitím.NET:

	[System.Reflection.Assembly]::LoadWithPartialName("System.Drawing")
	$installedFonts = New-Object System.Drawing.Text.InstalledFontCollection
	$installedFonts.Families | % {$_.Name}

Vypíšte zoznam všetkých vyhľadávacích strojov v Internet Exploreri a URL adries, ktorými sa vyhľadáva
------------------------------------------------------------------------------------------------------
	
	dir "HKCU:\Software\Microsoft\Internet Explorer\SearchScopes" | % {$_.GetValue("DisplayName") + ": " + $_.GetValue("URL") }

Opäť využijeme providera pre registre. "Jednotka" `HKCU:` zodpovedá registru `HKEY_CURRENT_USER`, nastaveniam špecifickým pre konkrétneho používateľa. 

Registre vracajú položku `RegistryKey`, čo je kvázi-mapa z kľúčov do hodnôt. Metódou `GetValue()` vieme získať hodnotu na základe daného kľúča.

Zistite, či je nastavená systémová premenná `JAVA_HOME`
------------------------------------------------------

	dir Env:\JAVA_HOME | select value

Provider `Env:` slúži na premenné prostredia.

Alternatívne cez registre:

	(gi "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment").GetValue("JAVA_HOME")


Nastavte `JAVA_HOME` pre všetkých používateľov na `C:\java\jdk6`.
----------------------------------------------------------------
 
	(gi "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment").SetValue("JAVA_HOME", "C:\Java\JDK")


Vytvorte v domovskom adresári súbor `ahoj.txt` s obsahom `AHOJ`
---------------------------------------------------------------

	echo "Ahoj" > ahoj.txt

Toto je klasická finta známa ešte z čias MS-DOSu (a fungujúca aj na Linuxe).

Alternatívne: pošlime do rúry reťazec a cez `Set-Content` ho uložme do súboru. 

	"AHOJ" | Set-Content ahoj.txt

Alternatívne:

	"AHOJ" | sc ahoj.txt

Overte existenciu súboru `ahoj.txt`
-----------------------------------

	cat ahoj.txt

Toto je klasická linuxovina. V skutočnosti je `cat` alias pre `Get-Content` (`gc`):

	Get-Content ahoj.txt 

Vytvorte v domovskom adresári zoznam desiatich súborov tyzden1.txt ... tyzden10.txt
-----------------------------------------------------------
	1..10 | % {"" | set-content tyzden$_.txt}

Zistite adresár, v ktorom sa nachádzajú položky Plochy.
-----------------------------------------------------------
Informáciu možno získať z registrov z položky `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders`, v kľúči `Desktop`. 

Overte, že sa naozaj v registroch nachádza. Položka je typu expandovateľný reťazec a premenná `%USERPROFILE%` sa automaticky expanduje na správnu hodnotu podľa aktuálne prihláseného používateľa.

	(gi 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders').GetValue("Desktop")

Vytvorte na ploche súbor poznamky.txt
-----------------------------------------------------------

	$DesktopDir = (gi 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders').GetValue("Desktop")
	"" | sc $DesktopDir\poznamky.txt

Stiahnite z PowerShellu súbor http://ics.upjs.sk/~novotnyr/home/skola/systemove_programovanie/mena.txt
-----------------------------------------------------------

	(New-Object System.Net.WebClient).DownloadString("http://ics.upjs.sk/~novotnyr/home/skola/systemove_programovanie/mena.txt") | Set-Content mena.txt

V textovom editore vytvorte súbor mena.txt s nasledovným obsahom:
-----------------------------------------------------------

	Jozef Košický,študent,Hlavná 25,Košice
	Milan Košický,študent,Leninova 66,Košice
	Zuzana Mikulášska,zamestnankyňa,Poľná 25, Liptovský Mikuláš
	Júlia Spišskohôrna,študentka,Alana Turinga 25, Spišská Hôrna
	Jeremiáš Prešovský,školník,Industriálna 15, Prešov

Vypíšte obsah súboru `mena.txt`
-------------------------------

	Get-Content mena.txt

Alternatívne:

	gc mena.txt

Vypíšte len riadky, ktoré obsahujú študentov
-----------------------------------------------------------
	
	Get-Content mena.txt | where {$_ -like "*študent*"}

Alternatívne:

	gc mena.txt | ? {$_ -like "*študent*"}

Alternatívne:

	gc mena.txt | ? {$_ -match "študent"}

Súbor je reprezentovaný ako zoznam reťazcových riadkov, overte to:
-----------------------------------------------------------

	Get-Content mena.txt | Get-Member

Vypíšte len riadky, ktoré obsahujú študentov začínajúcich sa na „J“
-----------------------------------------------------------

	Get-Content mena.txt | where {$_ -like "J*"}

Vypíšte len riadky, ktoré sa začínajú sa na „J“ a reprezentujú len zamestnancov
-----------------------------------------------------------

	Get-Content mena.txt | where {($_ -like "J*") -and ($_ -notlike "*zamestnanec*")}

Vypíšte jednotlivé slová z gramatickej vety zadanej na vstupe
-----------------------------------------------------------

	"Byť, či nebyť, to je otázka".split()

Metóda `split()` rozdelí text podľa oddeľovača, výsledkom je zoznam s jednotlivými oddelenými prvkami.

Alternatívne sa dá použiť operátor –split

	"Ahoj svet" -split " "

Z textu „Ahoj svet“ vypíšte len prvé slovo
-----------------------------------------------------------

	"Byť, či nebyť, to je otázka".split()[0]

K zoznamu môžeme pristupovať pomocou poľovej notácie.

Alternatívne:

	("Byť, či nebyť, to je otázka" -split " ")[0]

Alternatívne:

	"Byť, či nebyť, to je otázka" -split " " | select -first 1

Vypíšte len mená zo súboru `mena.txt`
-----------------------------------------------------------
	get-content mena.txt | % {$_.split(",")[0]}

Metóda `split()` má parameter, kde vieme špecifikovať oddeľovač. (Implicitný oddeľovač je medzera).

Vypíšte mená, ktoré sa končia na „A“
------------------------------------

	get-content mena.txt | % {$_.split(",")[0]} | ? {$_ -like "*a"}

Alternatívne pomocou regulárnych výrazov:

	get-content mena.txt | ? {$_ -match ".+a,"}

Vypíšte ľudí, ktorých priezvisko sa začína na „K“
-----------------------------------------------------------

	get-content mena.txt | ? {$_ -match "^(.+) K"}

Vypíšte iniciály mien
---------------------

	get-content mena.txt | ? {$_ -match "^(.).+? (.).+"} | % {$matches[1] + ". " + $matches[2] + "."}

Nahraďte v súbore `mena.txt` výskyt „študent“ výskytom „poslucháč“
-----------------------------------------------------------
Prvý chybný nástrel:

	gc mena.txt | % {$_ -replace "študent", "poslucháč"} | sc mena.txt

Dostaneme hlášku `The process cannot access the file because it is being used by another process`. Namiesto toho uložme výstup do separátneho súboru, originálny súbor zmažme a nový výstup premenujme (toto vyžaduje trojriadkový skript).

Zistite frekvencie jednotlivých slov v súbore
---------------------------------------------

	gc babel.txt | % { 
	    $_.split() | % { 
	        $_.toLower().Trim() -replace "[^a-z]", "" | ? {$_.Length -ge 0 }
	    }  
	} | Group-Object | Sort Count


*	Vyjdime z cmdletu `Get-Content`, ktorý pošle do rúry jednotlivé riadky súboru. 
*	Každý riadok rozdelíme na slová cez `Split`: vzniknú tým jednotlivé slová, ktoré preiterujeme v podrúre.
*	Každé slovo zhodíme na malé písmená, odsekneme začiatočné a koncové medzery a každé nepísmeno nahradíme prázdnym znakom. Zároveň do rúry pošleme len slová, ktorá po upratovaní majú stále nenulovú dĺžku.
*	Všetky slová zgrupneme cez `Group-Object`, čím získame frekvencie.
*	Tie už len potriedime podľa počtu a sme hotoví.

PowerShell ISE
==============
Zoznámte sa s PowerShell ISE
----------------------------

Spustite ISE pod právami administrátora
---------------------------------------

Overte správanie pri otváraní uložených skriptov
------------------------------------------------
Otvorenie existujúcich skriptov spôsobí problémy pri spúšťaní.

	File C:\Users\novotnyr\hello.ps1 cannot be loaded because the execution of scripts is  disabled on this system. Please see "get-help about_signing" for more details.
	At line:0 char:0

Zmeniť možno politiku vykonávania skriptov

	Set-ExecutionPolicy -ExecutionPolicy RemoteSigned

Následne treba odsúhlasiť v GUI zmenu politiky. Táto politika umožní spúšťať všetky skripty, ale tie, ktoré sa stiahli z webu, musia byť digitálne podpísané.

Konštrukcie z procedurálneho programovania
==========================================
Oboznámte sa so syntaxou premenných. Vypočítajte cenu s DPH.
------------------------------------------------------------

	$cena = 1200
	$dph = 0.21
	($cena * $dph) + $dph

Premenné v Powershelli sú uvádzané dolármi, podobne ako v PHP, či Perli. 

Overte dátový typ premennej `$cena`
------------------------------------------------------------
	
	$cena | Get-Member

Dátové typy využívajú objektový model z .NET frameworku.

Zistite názvy najčítanejších článkov za posledné 4 hodiny na portáli SME.sk.
-----------------------------------------------------------
	$rss = (New-Object System.Net.WebClient).DownloadString("http://rss.sme.sk/rss/rss.asp?id=smenajcit4")
	$xml = [xml] $rss;
	$xml.rss.channel.item | % {$_.title}

*	Metódou `DownloadString` stiahneme reťazec.
*	Pretypujeme ho na XML objekt reprezentovaný typom `[xml]`
*	po elementoch v strome skáčeme klasickou bodkovou notáciou
*	dokonca atribúty sa zjavia ako vlastnosti (properties)

Zistite kurz českej koruny z http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml
----------------------------

	$currency = "CZK"
	$xml = [xml] (New-Object System.Net.WebClient).DownloadString("http://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml")
	$xml.Envelope.Cube.Cube.Cube | ? {$_.currency -eq $currency } | select rate

*	použijeme filozofiu z predošlej úlohy
*	bonus: atribúty sa zjavia ako vlastnosti (properties)
*	menné priestory v XML nemusíme vôbec riešiť.
*	pri porovnávaní pozor na operátor! Používame `-eq`, a nie `==`.


Vypíšte 10x text `Budem si robiť domáce úlohy.`
------------------------------------------------------------

	for ($i = 0; $i -lt 10; $i++) {
	    echo "Budem si robiť domáce úlohy."
	}

Cyklus `for` využíva klasickú C/C++/Java/C# syntax. Pozor na

* deklaráciu premenných
* porovnávanie dvoch hodnôt: namiesto `<` použite `-lt`.

Alternatívne: príkaz `echo` nie je povinný, keďže samotný reťazec predstavuje výraz, ktorý sa pošle do rúry a teda do výstupu.

	for ($i = 0; $i -lt 10; $i++) {
	    "Budem si robiť domáce úlohy."
	}

Vypíšte 10x text `Budem si robiť domáce úlohy.`, pričom použite `while
----------------------------------------------------------------------

	$i = 0
	while ($i -lt 10) {
	    "Budem si robiť domáce úlohy."
	    $i++
	}

Napíšte ľubovoľný nekonečný cyklus
----------------------------------------------------------------------
Zlé riešenie:

	while (true) {
	    "Budem si robiť domáce úlohy."
	}

Hláška je

	The term 'true' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.

Výraz `true` v Powershelli nie je definovaný. 

Alternatívne:

	while (1) {
	    "Budem si robiť domáce úlohy."
	}

Každý nenulový výraz sa vyhodnotí na booleovskú hodnotu `pravda`.

Spočítajte frekvencie prípon súborov v adresári
-----------------------------------------------

	$extensionMap = @{}
	ls -R D:\MP3 | ? { $_.Mode -notmatch "d" } | % { 
	    if(! $extensionMap.containsKey($_.Extension)) {
	        $extensionMap[$_.Extension] = 1
	    } else {
	        $extensionMap[$_.Extension]++
	    }
	}
	
	$extensionMap

*	Využime dátovú štruktúru *hash*; analógiu `HashMap` z iných jazykov.
*	Prázdny *hash* vytvoríme cez `@{}`, získame objekt typu `System.Collections.Hashtable`
*	Vieme pristupovať cez `[...]` notáciu.
*	Existenciu kľúča overíme cez metódu `containsKey()`. 

Spočítajte frekvencie prípon súborov v adresári so zgrupovaním
---------------------------------------------------------------

	ls -R D:\MP3 | Group-Object Extension | Sort Count | ft Name, Count -a

`Group-Object` dokáže zgrupovať veci do množín podľa rozličných kritérií.

Zotrieďte danú hashtabuľku frekvencií podľa počtu výskytov
-----------------------------------------------------------

	$frekvencie = @{".m3u" = 3; ".mp3" = 790; ".flac" = 168; ".jpg" = 79}
	$frekvencie.GetEnumerator() | sort Name

*	hash môžeme vytvoriť aj s hodnotami: uvádzame ich v tvare *kľúč*=*hodnota* a oddeľujeme bodkočiarkou.
	*	častá chyba je oddeľovať ich čiarkou!
*	ak chceme triediť hash, musíme získať jeho enumerátor (analógia `Iterator` z Javy), ktorý z každej položky vytvorí separátny objekt a pošle ho do rúry. Klasické `$frekvencie | Sort` nebude fungovať! 

Funkcie
=======

Vytvorte funkciu `Get-Hello`, ktorá vypíše 10x "Hello World"
----------------------------------------------------------

	function Get-Hello {
		1..10 | % { "Hello World" }
	}

Funkciu zavoláme cez

	Get-Hello

Funkcie sa majú tváriť ako cmdlety a teda by mali dodržiavať konvenciu *sloveso*-*podstatné meno*.

Vytvorte funkciu `Get-Hello`, ktorá vypíše zadaný počet krát "Hello World"
--------------------------------------------------------------------------

	function Get-Hello($count) {
		1..$count | % { "Hello World" }
	}
	
	Get-Hello 3

Pri parametroch je často vhodné uviesť implicitnú hodnotu. Ak totiž zavoláme len

	Get-Hello

Uvidíme výpis:

	Hello World
	Hello World

Funkcia totiž bude iterovať od 1..0, čiže dvakrát. Úprava:

	function Get-Hello($count=1) {
		1..$count | % { "Hello World" }
	}

Vytvorte funkciu `Write-RepeatedMessage`, ktorá vypíše zadaný počet krát text
--------------------------------------------------------------------------

	function Write-RepeatedMessage($message, $count = 1) {
		1..$count | % { $message }
	}

Správne volanie:

	Write-RepeatedMessage "Hello World" 2

Zlé volanie, aj keď prirodzené:

	Write-RepeatedMessage("Hello World", 2)

Vypíše totiž:

	Hello World
	2

Toto nefunguje! Funkcie sa majú tváriť ako cmdlety, preto žiadne zátvorkové volanie nefunguje. Toto nesprávne volanie zavolá funkciu s jedným parametrom typu *dvojprvkové pole*. PowerShell ho vypíše raz a keďže polia sa transformujú na jednotlivé prvky poslané do rúry, uvidíme presne tento výpis. 

Skúste si to napríklad s 

	Write-RepeatedMessage("Hello World", 2, "Ding", "Dong")

Parametre oddeľujeme medzerami!

WTF správanie môžeme vylepšiť dodaním dátových typov

	function Write-RepeatedMessage([string] $message, [int] $count = 1) {
		1..$count | % { $message }
	}
	
	Write-RepeatedMessage("Hello World", 2)

Toto povedie k výpisu:

	Hello World 2

Vytvorte funkciu, ktorá vypíše čísla *od* hranice *po* hranicu s *krokom*
-------------------------------------------------------------------------

	function Get-Sequence([int] $from, [int] $to, [int] $step = 1) {
		for($i = $from; $i -le $to; $i = $i + $step) {
			$i
		}
	}

Volanie:

	Get-Sequence 1 10 3

Aby sme predišli kadejakému WTF, deklarujme dátové typy. Ak máme len hlavičku

	function Get-Sequence($from, $to, $step) {

Môžeme zavolať:

	Get-Sequence "" "Badger Badger Badger Badger Mushroom Mushroom" "Badger "

A máme nekonečný cyklus.

Ak deklarujeme dátové typy, uvidíme hlášku:

	Get-Sequence : Cannot process argument transformation on parameter 'to'. Cannot convert value "Badger Badger Badger Badger Mushroom Mushroom" to type "System.
	Int32". Error: "Input string was not in a correct format."
   


Vytvorte funkciu `Get-HomeDirectory`, ktorá pre zadaného používateľa vráti jeho domovský adresár
------------------------------------------------------------------------------------------------

	function Get-HomeDirectory($username) {
	    $sid = (gwmi win32_useraccount -filter "name = '$username'").sid
	    (gwmi win32_userprofile -filter "sid = '$sid'").LocalPath
	}

Volanie:

	Get-HomeDirectory "rn"

Výpis [na Windows 8.1]:

	C:\Users\rn

Využijeme funkcie z WMI. Špecialita je interpolácia reťazcov: ak máme premennú `$username`, a chceme ju použiť vo vnútri reťazca, nemusíme ich lepiť. Dolárové premenné vo vnútri reťazcov sa automaticky nahradia ich hodnotami:

	"name = '$username'"

pre `$username = "rn"` po interpolácii vznikne reťazec `"name = 'rn'"`.

Vytvorte funkciu `Get-HomeDirectory`, ktorá vypíše domovský adresár používateľa z rúry
--------------------------------------------------------------------------------------

	function Get-HomeDirectory {
	    foreach($username in $input) {
	        $sid = (gwmi win32_useraccount -filter "name = '$username'").sid
	        (gwmi win32_userprofile -filter "sid = '$sid'").LocalPath
	    }
	}

Volanie:

	"rn", "UpdatusUser" | Get-HomeDirectory

Každá funkcia má skrytú premennú `$input`, ktorá je kolekcia s prvkami prichádzajúcimi z rúry.

 
Vytvorte funkciu, ktorá zistí celkové veľkosti adresárov (rekurzívne)
---------------------------------------------------------------------

	function Measure-Directory {
	    foreach($item in $input) {
	        $size = (dir $item.FullName -Recurse | Measure-Object -Sum -Property Length).Sum
	        @{$item.FullName = $size}
	    }
	}

Volanie:

	ls D:\MP3 | Measure-Directory

Alebo:

	"D:\MP3\Ectasy of Saint Theresa", "D:\MP3\Happy Melon"  | Get-Item | Measure-Directory

Očíslujte položky z rúry
------------------------

	function Enumerate-Items {
		$itemIndex = 0;
		foreach($item in $input) {
			@{$itemIndex = $item}
			$itemIndex++
		}
	}

Volanie:

	dir | Enumerate-Items

Očíslujte položky z rúry [alternatívna syntax]
----------------------------------------------

	function Enumerate-Items {
		begin {
			$itemIndex = 0;
		}
		process {
			@{$itemIndex = $_}
			$itemIndex++
		}
	}

Funkcia môže pozostávať z troch blokov:

*	`begin`: vykoná sa pred spracovaním prvého objektu z rúry
*	`end`: vykoná sa po spracovaní posledného objektu z rúry
*	`process`: vykoná sa pre každý objekt z rúry samostatne. V premennej `$_` sa zjaví aktuálny objekt, ktorý prichádza z rúry.

Vytvorte filter, ktorým spočítate veľkosť adresárov z rúry
-----------------------------------------------------------

	filter Measure-Directory {
        $size = (dir $_.FullName -Recurse | Measure-Object -Sum -Property Length).Sum
        @{$_.FullName = $size}
	}

Funkcia, ktorá má len blok `process`, sa nazýva *filter*. Riešenie je ekvivalentné 

	function Measure-Directory {
	    foreach($item in $input) {
	        $size = (dir $item.FullName -Recurse | Measure-Object -Sum -Property Length).Sum
	        @{$item.FullName = $size}
	    }
	}

a ekvivalentné:

	function Measure-Directory {
		process {
        	$size = (dir $_.FullName -Recurse | Measure-Object -Sum -Property Length).Sum
        	@{$_.FullName = $size}
		}
	}

Zistite, ktoré procesy sú systémovo náročné (> 60% CPU)
-------------------------------------------------------

	filter Get-CpuHeavyProcess {
	    if($_.PercentProcessorTime -ge 60) {
	        $obj = New-Object PSObject | Select Name, CPU
	        $obj.Name = $_.Name;
	        $obj.CPU = $_.PercentProcessorTime;
	        $obj
	    }
	}
	gwmi Win32_PerfFormattedData_PerfProc_Process | Get-CpuHeavyProcess

Vyrobíme jednoduchý filter, ktorý sa díva na vlastnosť `PercentProcessorTime`.

Zároveň demonštrujeme dynamické vytváranie objektu.
